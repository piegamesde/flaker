mod diffing;
mod errors;
mod indexing;
mod reporting;

use crate::indexing::SourceSet;
use crate::reporting::{report, ReportVerbosity};
use clap::{Args, Parser};
use color_eyre::eyre::{eyre, Result};
use enumset::EnumSet;
use std::fs::File;
use std::io::prelude::*;
use std::path::PathBuf;
use std::str::FromStr;

#[derive(Args, Debug, Clone)]
pub struct GithubOptions {
    /// Authentification Token used to search github
    #[arg(long)]
    auth_token: Option<String>,
    /// On which page to start the search
    #[arg(long, default_value_t = 1)]
    start_page: usize,
    /// On which page to end early
    #[arg(long)]
    end_page: Option<usize>,
}

#[derive(Parser, Debug)]
#[command(
    version,
    about,
    arg_required_else_help = true,
    // Confirm clap defaults
    propagate_version = false,
    disable_colored_help = false,
    color = clap::ColorChoice::Auto
)]
enum Command {
    /// Build an index of repositories based on source sets
    BuildIndex {
        /// Which source sets to include.
        #[arg(long, value_enum)]
        sources: Vec<SourceSet>,
        #[command(flatten)]
        github_options: GithubOptions,
        /// Where to write the npins lock file
        #[arg()]
        out: PathBuf,
    },
    /// Run two Nix versions on all sources and diff the results
    NixParse {
        /// Path to the output file, will be overridden if present
        #[arg(long, short, default_value = "report.json")]
        output_file: PathBuf,
        /// Path to the folder to diff
        #[arg()]
        folder: PathBuf,
        /// Path to a Nix binary
        #[arg()]
        nix_a: PathBuf,
        /// Path to a Nix binary
        #[arg()]
        nix_b: PathBuf,
    },
    /// Prints a human-readable summary of a Diffing result (generated by NixParse)
    /// Default: auto (detailed with single file, summary for multiple
    Report {
        /// In which level of detail to print
        #[arg(long, short, default_value = "")]
        verbosity: String,
        /// Path to the report file
        #[arg(num_args = 1..)]
        report_paths: Vec<PathBuf>,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    use tracing_subscriber::prelude::*;
    tracing_subscriber::registry()
        .with(tracing_subscriber::filter::LevelFilter::from_level(
            tracing::Level::INFO,
        ))
        .with(
            tracing_subscriber::fmt::layer()
                .with_target(true)
                .with_span_events(tracing_subscriber::fmt::format::FmtSpan::NEW),
        )
        .with(tracing_error::ErrorLayer::default())
        .init();

    color_eyre::install()?;

    match Command::parse() {
        Command::BuildIndex {
            sources,
            github_options,
            out,
        } => {
            let sources = if sources.len() == 0 {
                EnumSet::all()
            } else {
                EnumSet::from_iter(sources)
            };
            indexing::build_index(sources, github_options, out).await?;
        }
        Command::NixParse {
            folder,
            nix_a,
            nix_b,
            output_file,
        } => {
            let result = diffing::diff_parsers(folder, nix_a, nix_b).await?;
            let out_file_attempt = File::create(output_file);
            let mut out_file = out_file_attempt.unwrap_or_else(|e| {
                tracing::error!("Error creating file; writing to ./report.json; {}", e);
                File::create("./report.json").unwrap()
            });
            out_file.write_all(
                serde_json::to_string_pretty(&result)?
                    .into_bytes()
                    .as_slice(),
            )?;
        }
        Command::Report {
            verbosity,
            report_paths,
        } => {
            let verbosity = ReportVerbosity::from_str(verbosity.as_str())
                .map_err(move |()| eyre!("Invalid verbosity '{}'", verbosity))?;
            report(report_paths, verbosity)?;
        }
    }
    Ok(())
}
