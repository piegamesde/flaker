mod diffing;
mod indexing;
mod reporting;

use crate::reporting::{report, ReportVerbosity};
use clap::{Parser, Subcommand};
use color_eyre::eyre::{eyre, Context, Result};
use enumset::EnumSetType;
use futures::Stream;
use std::fs::File;
use std::io::prelude::*;
use std::path::PathBuf;
use std::str::FromStr;
use tracing::Instrument;

#[derive(Parser, Debug)]
#[command(
    version,
    about,
    arg_required_else_help = true,
    // Confirm clap defaults
    propagate_version = false,
    disable_colored_help = false,
    color = clap::ColorChoice::Auto
)]
enum Command {
    /// Build an index of repositories based on source sets
    BuildIndex {
        /// Which source sets to include.
        /// Comma separated list. Available source sets: `nixpkgs`, `nur`, `github`
        #[arg(long, default_value = "*")]
        sources: String,
        #[arg()]
        out: PathBuf,
    },
    /// Run two Nix versions on all sources and diff the results
    NixParse {
        /// Path to the output file, will be overridden if present
        #[arg(long, short, default_value = "report.json")]
        output_file: PathBuf,
        /// Path to the folder to diff
        #[arg()]
        folder: PathBuf,
        /// Path to a Nix binary
        #[arg()]
        nix_a: PathBuf,
        /// Path to a Nix binary
        #[arg()]
        nix_b: PathBuf,
    },
    /// Prints a human-readable summary of a Diffing result (generated by NixParse)
    /// Default: auto (detailed with single file, summary for multiple
    Report {
        /// In which level of detail to print
        #[arg(long, short, default_value = "")]
        verbosity: String,
        /// Path to the report file
        #[arg(num_args = 1..)]
        report_paths: Vec<PathBuf>,
    },
}

#[tokio::main]
async fn main() -> Result<()> {
    use tracing_subscriber::prelude::*;
    tracing_subscriber::registry()
        .with(tracing_subscriber::filter::LevelFilter::from_level(
            tracing::Level::DEBUG,
        ))
        .with(
            tracing_subscriber::fmt::layer()
                .with_target(true)
                .with_span_events(tracing_subscriber::fmt::format::FmtSpan::NEW),
        )
        .with(tracing_error::ErrorLayer::default())
        .init();

    color_eyre::install()?;

    match Command::parse() {
        Command::BuildIndex { sources, out } => {
            use crate::indexing;
            let sources = if sources.contains('*') {
                enumset::EnumSet::all()
            } else {
                sources
                    .split(',')
                    .map(indexing::SourceSet::from_str)
                    .collect::<std::result::Result<_, ()>>()
                    .map_err(move |()| eyre!("Invalid source set '{}'", sources))?
            };
            indexing::build_index(sources, out).await?;
        }
        Command::NixParse {
            folder,
            nix_a,
            nix_b,
            output_file,
        } => {
            let result = diffing::diff_parsers(folder, nix_a, nix_b).await?;
            let mut out_file = File::create(output_file)?;
            out_file.write_all(
                serde_json::to_string_pretty(&result)?
                    .into_bytes()
                    .as_slice(),
            )?;
        }
        Command::Report {
            verbosity,
            report_paths,
        } => {
            let verbosity = ReportVerbosity::from_str(verbosity.as_str())
                .map_err(move |()| eyre!("Invalid verbosity '{}'", verbosity))?;
            report(report_paths, verbosity)?;
        }
    }
    Ok(())
}
